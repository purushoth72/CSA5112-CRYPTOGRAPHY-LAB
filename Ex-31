from Crypto.Cipher import AES

# Constants for CMAC (for AES block size = 128 bits)
BLOCK_SIZE = 16  # 128 bits
Rb = 0x87        # Constant for AES (128-bit block size)

def xor_bytes(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

def left_shift_one_bit(block):
    shifted = int.from_bytes(block, byteorder='big') << 1
    shifted &= (1 << (BLOCK_SIZE * 8)) - 1  # Mask to block size
    return shifted.to_bytes(BLOCK_SIZE, byteorder='big')

def generate_subkeys(key):
    cipher = AES.new(key, AES.MODE_ECB)
    L = cipher.encrypt(b'\x00' * BLOCK_SIZE)

    # Generate K1
    if (L[0] & 0x80) == 0:
        K1 = left_shift_one_bit(L)
    else:
        K1 = xor_bytes(left_shift_one_bit(L), b'\x00' * (BLOCK_SIZE - 1) + bytes([Rb]))

    # Generate K2
    if (K1[0] & 0x80) == 0:
        K2 = left_shift_one_bit(K1)
    else:
        K2 = xor_bytes(left_shift_one_bit(K1), b'\x00' * (BLOCK_SIZE - 1) + bytes([Rb]))

    return K1, K2

# Example usage
key = b'\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c'  # 128-bit AES key
K1, K2 = generate_subkeys(key)

print("Subkey K1:", K1.hex())
print("Subkey K2:", K2.hex())
