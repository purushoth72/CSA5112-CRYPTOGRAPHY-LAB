import math

# Step 1: Factor n to find p and q
def factor_n(n):
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return i, n // i
    return None, None

# Step 2: Compute φ(n) = (p - 1)(q - 1)
def compute_phi(p, q):
    return (p - 1) * (q - 1)

# Step 3: Extended Euclidean Algorithm to find modular inverse
def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd, x, y

def mod_inverse(e, phi):
    gcd, x, _ = extended_gcd(e, phi)
    if gcd != 1:
        raise Exception("No modular inverse exists")
    return x % phi

# Step 4: Main RSA private key computation
def find_private_key(e, n):
    p, q = factor_n(n)
    if not p or not q:
        raise ValueError("Failed to factor n")
    print(f"Factors of n: p = {p}, q = {q}")
    phi = compute_phi(p, q)
    print(f"Euler's totient φ(n) = {phi}")
    d = mod_inverse(e, phi)
    print(f"Private key d = {d}")
    return d

# Given public key
e = 31
n = 3599

# Compute private key
d = find_private_key(e, n)
