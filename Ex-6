import string

def mod_inverse(a, m):
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

def affine_decrypt(ciphertext, a, b):
    ciphertext = ciphertext.upper()
    plaintext = ""
    a_inv = mod_inverse(a, 26)
    if a_inv is None:
        raise ValueError("Invalid 'a' â€” no modular inverse exists.")
    for ch in ciphertext:
        if ch.isalpha():
            c = ord(ch) - ord('A')
            p = (a_inv * (c - b)) % 26
            plaintext += chr(p + ord('A'))
        else:
            plaintext += ch
    return plaintext


ciphertext = input("Enter ciphertext: ").strip().upper()

# From frequency analysis, found a=3, b=15
a, b = 3, 15

print(f"Using keys: a = {a}, b = {b}")
decrypted = affine_decrypt(ciphertext, a, b)
print("Decrypted text:", decrypted)
