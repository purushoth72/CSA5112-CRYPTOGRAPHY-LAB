import string
from math import gcd


ALPHABET = string.ascii_uppercase

def mod_inverse(a, m):
    """Find modular inverse of a under mod m using Extended Euclidean Algorithm."""
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None  

def affine_encrypt(plaintext, a, b):
    """Encrypt plaintext using Affine Cipher: C = (a*p + b) mod 26"""
    ciphertext = ""
    for char in plaintext.upper():
        if char.isalpha():
            p = ord(char) - ord('A')
            c = (a * p + b) % 26
            ciphertext += chr(c + ord('A'))
        else:
            ciphertext += char
    return ciphertext

def affine_decrypt(ciphertext, a, b):
    """Decrypt ciphertext using Affine Cipher: p = a_inv * (C - b) mod 26"""
    plaintext = ""
    a_inv = mod_inverse(a, 26)
    if a_inv is None:
        raise ValueError("Invalid 'a' — no modular inverse exists (gcd(a,26) ≠ 1).")
    for char in ciphertext.upper():
        if char.isalpha():
            c = ord(char) - ord('A')
            p = (a_inv * (c - b)) % 26
            plaintext += chr(p + ord('A'))
        else:
            plaintext += char
    return plaintext


if __name__ == "__main__":
    print("Affine Caesar Cipher")
    mode = input("Mode (E=encrypt, D=decrypt): ").strip().upper()
    text = input("Enter text: ").strip().upper()
    a = int(input("Enter value of a: "))
    b = int(input("Enter value of b: "))

    if gcd(a, 26) != 1:
        print("Error: Invalid value of 'a' (gcd(a, 26) ≠ 1). Choose a coprime with 26.")
    else:
        if mode == 'E':
            cipher = affine_encrypt(text, a, b)
            print("Ciphertext:", cipher)
        elif mode == 'D':
            plain = affine_decrypt(text, a, b)
            print("Decrypted text:", plain)
        else:
            print("Invalid mode. Use E or D.")
